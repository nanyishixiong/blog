# 首屏速度优化

## 传输

### DNS域名解析优化

DNS缓存

### CDN 回源 预热

CDN回源是指当CDN节点上没有所请求的内容时，CDN会向源服务器（也称为回源服务器）发送请求，从源服务器获取所需内容，然后将内容缓存到CDN节点，最后再将内容传送给用户。CDN回源的过程可以简单描述为用户请求 -> CDN节点 -> 回源服务器 -> CDN节点 -> 用户响应。

CDN回源的目的是为了保证用户能够尽快地获取到所需内容，尤其是当内容在CDN节点上不存在或已过期时。通过将内容缓存到离用户更近的CDN节点，可以减少请求的延迟和网络拥塞，提高内容的传输速度和用户访问的响应时间。

CDN预热是指在用户请求到来之前，提前将内容缓存到CDN节点的过程。通常在发布新内容、更新内容或者进行系统维护时，可以通过CDN预热来加速内容的分发和访问。

CDN预热的目的是为了避免用户第一次请求时，由于内容尚未缓存到CDN节点而导致的延迟。通过预热，可以提前将内容主动地缓存到CDN节点，使得用户在请求到来时能够快速获取到内容，减少用户等待时间。

CDN预热可以通过手动触发预热请求或者通过API接口进行自动预热。预热的内容可以是单个文件、目录、网页等，具体根据需求和使用场景来确定。

### SSL握手

HTTP2 SSL交换密钥耗时  采用TLS1.3 代替 TLS1.2

1. 握手过程：TLS1.3 把 **Hello** 和 **公钥交换** 两个消息合并成一个消息，从 4次握手2个RTT，减少到 2次握手1个RTT 就可以完成TLS握手。
2. 密钥交换算法：用 ECDHE 算法 替换RSA算法（速度慢，安全性不高）

### HTTP协议

使用http2，多路复用的特性，头部压缩，请求优先级

### 浏览器缓存

- 强缓存和协商缓存的区别
- nginx中应该如何配置缓存字段
- 分包加载，如何避免一行代码修改导致整个 bundle 的缓存失效

### 减少请求数量

1. 精灵图（解决HTTP1.0时代TCP复用问题）
2. 小于5kb的图片用base64打包到代码中

```json
// webpack 配置 小于5kb的图片用base64打包到代码中
{
  loader: 'url-loader',
  options: {
      limit: 5 * 1024,
      outputPath: '/img1/',
  }
}
```



## 体积

### 代码分割

代码分割，公共代码提取到一个chunk，避免重复加载

代码分割，按需加载

缓存优化，把不常变动的模块打包成一个chunk，利用缓存机制

### 压缩包体积

1. uglify-js压缩JS体积，webpack optimization.minimizer 默认采用 **TerserPlugin** 进行JS代码压缩，用户可自定义配置来覆盖原有的 TerserPlugin 
2. MiniCssExtractPlugin 压缩CSS体积
3. Gzip压缩（开启方式：webpack，nginx，一般在nginx服务器开启，根据浏览器能够接受的压缩算法进行压缩）
4. Tree-shaking：原理，收集模块导出，标记未使用过的模块导出，生成代码，再由 Terser 删除Dead Code。
5. 图片大小的优化：使用webp格式替换原有的png/jepg
6. 三方库的按需加载，按需打包

## 渲染

### 对关键资源的预加载，对非关键资源的延后加载

**preload 和 prefecth**

Preload（预加载）：`<link rel="preload">` 指令用于在页面加载过程中提前请求关键资源。

Prefetch（预获取）：`<link rel="prefetch">` 指令用于在浏览器空闲时提前获取未来可能需要的资源，以优化后续页面的加载速度。

**async 和 defer**

如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行。

`async` 属性：当脚本标签使用 `async` 属性时，脚本将异步加载，加载完立即执行，可能阻塞 HTML 解析；多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。

`defer` 属性：并行加载脚本，载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

**域名预解析**

使用 `<link rel="dns-prefetch">` 标签可以指示浏览器在后台解析指定的域名。这样，当浏览器需要建立与该域名的连接时，它已经预先解析了域名对应的 IP 地址，从而加快了连接的建立速度。

```html
<link rel="dns-prefetch" href="https://example.com">
<link rel="dns-prefetch" href="https://cdn.example.com">
```

**懒加载，虚拟列表**

延迟加载非关键资源，直到用户需要使用它们时再进行加载。例如，当用户滚动到可见区域或触发某个事件时，再加载图片、视频或其他组件。

### 防抖和节流



### 优化 JS 执行效率

1. 动画实现使用requestAnimationFrame
2. 长耗时的JS代码放到Web Workers中执行
3. 拆分操作DOM元素的任务，分别在多个frame完成
   + 由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到 `requestAnimationFrame`中回调执行

### 减少重排重绘

1. 使用 CSS3 动画和过渡：CSS3 提供了 `transform` 和 `opacity` 等属性，它们在进行动画和过渡时可以利用硬件加速，减少重排和重绘的次数。相比使用 `top`、`left` 等属性进行动画，使用 CSS3 动画更高效。
2. 批量修改样式：在进行多次样式修改时，尽量将它们合并为一次操作，通过修改元素的 class 名称一次性应用多个样式。这样可以减少多次重排和重绘的发生。
3. 使用文档片段（Document Fragment）：如果需要对 DOM 进行多次操作，可以先将 DOM 元素添加到文档片段中，然后再将整个文档片段一次性插入文档中。这样可以避免每次操作都触发重排和重绘。
4. 避免强制同步布局：某些操作需要获取元素的布局信息，如使用 `offsetTop`、`offsetWidth` 等属性，或调用 `getBoundingClientRect()` 方法。这些操作会强制浏览器进行同步布局，导致重排的发生。尽量避免在频繁执行的代码路径中使用这些属性和方法，或者将它们的调用移到一次性的操作中。
5. 使用 `display: none` 隐藏元素：使用 `display: none` 隐藏元素可以避免元素的重排和重绘。因为隐藏的元素不会占据布局空间，对它进行修改不会影响其他元素的位置和尺寸。但要注意，当元素从隐藏状态切换为显示状态时，会触发重排过程。
6. 使用虚拟 DOM 技术：虚拟 DOM 技术可以在内存中进行 DOM 操作，最后一次性将结果应用到实际的 DOM 结构，减少重排和重绘的次数。
7. 使用 CSS 属性 `will-change`：`will-change` 属性用于告诉浏览器哪些属性将要发生变化，以便浏览器在布局计算时进行优化。这可以减少由于样式变化而引起的重排和重绘。



## 与用户相关的性能指标

- **[首次内容绘制 (FCP)](https://web.dev/articles/fcp?hl=zh-cn)**：衡量从网页开始加载到网页任何部分呈现在屏幕上所用的时间。
- **[Largest Contentful Paint (LCP)](https://web.dev/articles/lcp?hl=zh-cn)**：衡量从网页开始加载到屏幕上渲染最大的文本块或图片元素所用的时间。
- **[首次输入延迟 (FID)](https://web.dev/articles/fid?hl=zh-cn)**：衡量从用户首次与您的网站互动（点击链接、点按按钮或使用由 JavaScript 提供支持的自定义控件）到浏览器实际能够响应该互动的时间。
- **[Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=zh-cn)**：衡量与网页进行每次点按、点击或键盘交互的延迟时间，并根据互动次数选择该网页最差的互动延迟时间（或接近最高延迟时间）作为单个代表性值，以描述网页的整体响应速度。(**反馈页面的卡顿情况**)
- **[可交互时间 (TTI)](https://web.dev/articles/tti?hl=zh-cn)**：衡量的是从网页开始加载到视觉呈现、其初始脚本（若有）已加载且能够快速可靠地响应用户输入的时间。
- **[总阻塞时间 (TBT)](https://web.dev/articles/tbt?hl=zh-cn)**：测量 FCP 和 TTI 之间的总时间，在此期间，主线程处于屏蔽状态的时间够长，足以阻止输入响应。
- **[Cumulative Layout Shift (CLS)](https://web.dev/articles/cls?hl=zh-cn)**：衡量从页面开始加载到其[生命周期状态](https://developer.chrome.com/blog/page-lifecycle-api/?hl=zh-cn)更改为隐藏之间发生的所有意外布局偏移的累计得分。
- **[首字节时间 (TTFB)](https://web.dev/articles/ttfb?hl=zh-cn)**：测量网络使用资源的第一个字节响应用户请求所需的时间。



SSR提升FCP，但对TTI可能是负作用。

SPA，对TTI是负作用，但有利于CLS（视觉稳定性）和INP(交互稳定性)



跳出率（Bounce Rate）和转化率（Conversion Rate）是两个关键的网站分析指标，用于评估网站的用户体验和业务目标达成情况。

1. 跳出率（Bounce Rate）：跳出率是指访问网站的用户在进入网站后只查看了单个页面并离开的比例。通常以百分比表示。跳出率高可能意味着用户对网站内容不感兴趣、导航不友好、加载速度慢或页面设计不吸引人等问题。较低的跳出率通常意味着用户更愿意在网站上浏览多个页面，表示用户对网站内容的吸引力和用户体验的好坏。
2. 转化率（Conversion Rate）：转化率是指完成特定目标的用户数量与访问网站的总用户数量之间的比例。这个特定目标可以是购买产品、填写表单、订阅通讯、下载文件等。转化率通常以百分比表示。高转化率表示网站成功地引导用户执行期望的行动，实现了预期的业务目标。转化率的提升可能需要优化网站内容、流程、设计和营销策略等。



