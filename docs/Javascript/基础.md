# JavaScript高频面试题

## 1、说说JavaScript中的数据类型？存储上的差别？

在 JavaScript 中，数据可以分成两种类型：

基本类型：Number，String，Boolean，Null，undefined，Symbol，BigInt

复杂类型：Object（包括Array，Function，Date等等）

两种类型的区别是：存储位置不同

+ 基本数据类型存储在栈中
+ 引⽤类型的对象存储于堆中

## 2、数据类型的判断

### 2.1 typeof 操作符

返回值是字符串：number，bigint，string，boolean，undefined，function，object，symbol

#### number

```js
//输出 number
console.log(typeof 1);
console.log(typeof NaN);  		 // 尽管他是Not-A-Number
console.log(typeof Number('1')); // Number 会尝试把参数解析成数值
console.log(typeof Infinity);	 // 无限大也是number
```

#### bigint

```js
console.log(typeof 42n);		 // 这个输出bigint
```

#### string

```js
//输出 string
console.log(typeof 'mc');
console.log(typeof '');
console.log(typeof `adadad`); // 模板字符串
console.log(typeof (typeof 1)); // typeof 操作符 返回字符串
console.log(typeof String(1)); // String 将任意值转换为字符串，比 toString 更安全
```

#### boolean

```js
//输出 boolean
console.log(typeof true);
console.log(typeof Boolean(1)); // Boolean(1)是true  Boolean(0)是false
console.log(typeof !!(1));// 两次调用 ! (逻辑非) 操作符相当于 Boolean() true
```

#### undefined

**声明但未初始化**和**未声明**  `typeof`输出都是"`undefined`"，但直接打印**未声明变量**是会报错的

```js
console.log(typeof undefined);          // undefined
console.log(typeof console.log());      // undefined
```

#### function

```js
console.log(typeof Symbol)              // function
console.log(typeof function () { });    // function
console.log(typeof new Function())      // function
```

#### object

```js
// object
console.log(typeof []);
console.log(typeof {});
console.log(typeof null);
console.log(typeof new Date()); // 除 Function 外的所有构造函数的类型都是 'object'
console.log(typeof /regex/);
```

#### symbol

```js
//symbol
console.log(typeof Symbol());
console.log(typeof Symbol('foo'));
console.log(typeof Symbol.iterator);
```

优点：能够快速区分基本数据类型
缺点：不能将Object、Array和Null区分，都返回object

**typeof 实现原理：**

js 在底层是怎么存储数据的类型信息呢？

其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息

+ 000：对象
+ 010：浮点数
+ 100：字符串
+ 110：布尔
+ 1：整数

但是，对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的。

`null`：所有机器码均为0

`undefined`：用 −2^30 整数来表示

所以，`typeof` 在判断 `null` 的时候就出现问题了，由于 `null` 的所有机器码均为0，因此直接被当做了对象来看待。

### 2.2 instanceof 运算符

`instanceof`运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。
`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```js
console.log(1 instanceof Number);                       // false
console.log(true instanceof Boolean);                   // false
console.log('str' instanceof String);                   // false
console.log([] instanceof Array);                       // true
console.log(function () { } instanceof Function);       // true
console.log({} instanceof Object);                      // true
```

优点：能够区分Array、Object、Function，适用于判断自定义的类实例对象
缺点：Nunber、boolean、String基本数据类型不能判断

#### instanceof 原理模拟实现

```js
function new_instance_of(leftVaule, rightVaule) {
    var rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;
        }
        if (leftVaule === rightProto) {
            return true;
        }
        leftVaule = leftVaule.__proto__
    }
}
```

其实 `instanceof` 主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

### 2.3 Object.prototype.toString.call()

```js
var toString = Object.prototype.toString;
console.log(toString.call(1));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('mc'));                   //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(function () { }));        //[object Function]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
console.log(toString.call(Symbol()));               //[object Symbol]
```

优点：精准判断数据类型
缺点：写法繁琐不容易记，推荐进行封装后使用

#### **简单封装**

```js
let typeUtil = {};
let types = ['String', 'Array', 'Number', 'Object', 'Undefined', 'Null', 'Boolean', 'Function', 'Symbol'];
types.forEach(type => {
  typeUtil['is' + type] = function (obj) {
    return Object.prototype.toString.call(obj) === `[object ${type}]`;
  }
})
console.log(typeUtil);
//{
//  isString: [Function (anonymous)],
//  isArray: [Function (anonymous)],
//  isNumber: [Function (anonymous)],
//  isObject: [Function (anonymous)],
//  isUndefined: [Function (anonymous)],
//  isNull: [Function (anonymous)],
//  isBoolean: [Function (anonymous)],
//  isFunction: [Function (anonymous)],
//  isSymbol: [Function (anonymous)]
//}
```

由于`String`基本包装类型的存在，在必要的时候`JS`引擎会把字符串字面量转换成一个`String`对象，从而可以执行访问属性和方法的操作

**Object**类型的每个实例都有`toString`方法，返回值为对象的字符串表示，所以每个实例化的对象都可以调用`toString`方法。

## 3、== 与 === 有什么区别（隐式转换）

== ：操作符两端类型不同会进行隐式转换再做比较，相等返回true，否则返回false

=== ：操作符两端操作数要完全相同，包括类型，才返回true，否则返回false

隐式转换规则

- 如果任一操作数是布尔值，则将其转换成数值再比较是否相等，flase转换为0，true转换为1
- 如果一个操作数是字符串，另一个操作数是数值，则调用 Number 方法将字符串转换为数值再进行比较是否相等
- 如果一个操作数是对象，另一个不是，则调用 valueof() 方法取得对象的原始值，再按前面的规则进行比较；如果没有 valueOf()操作符，则调用 toString()方法，再按前面的规则进行比较
- null 和 undefined 相等
- null 和 undefined 不能转换成其他类型的值再进行比较（仅限于 == 和 === ，其他比较符号还是会对这两个做隐式转换）
- 如果有任一操作数为 NaN 则相等操作符返回false，不相等操作符返回true，NaN不等于NaN
- 如果两个操作数是对象，则比较是不是同一个对象，是返回true，不是返回false

```js
// 2个字符串比较，对操作数调用 charCodeAt
'' == '0' // false 
// ''.charCodeAt(0) -> NaN  '0'.charCodeAt(0) -> 48

// 数字与字符串比较，对字符串调用Number方法
0 == '' // true
0 == '0' // true
' \t\r\n' == 0 // true
// Number('') -> 0 Number('0') -> 0 Number(' \t\r\n') -> 0 Number(空串)都是0

// 布尔值与字符串比较，将布尔值转成数字，再将字符串转为数字
false == 'false' // false
false == '0' // true
// Number(false) -> 0 Number('false') -> NaN Number('0') -> 0

// null 和 undefined 与任何其他值比较都为false
false == undefined // false
false == null // false
undefined == undefined // true
null == null // true
null == undefined // true

// 非 == 或 === 会对其做隐式转换 Number(null) => 0 Number(undefined) => NaN
null >= 0 // true
undefined >= 0 // false
```

## 4、JavaScript 的原型和原型链

JavaScript 常被描述为⼀种基于原型的语⾔——JavaScript 中的对象有一个私有属性`__proto__`，指向一个对象名曰**原型**(prototype)

当试图访问⼀个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到⼀个名字匹配的属性或到达原型链的末尾。

只要是对象，就会有`__proto__`属性指向它的原型，原型也是一个对象，也会有自己的原型。这种类似链表结构的关系就被称为**原型链**

![原型5](./image/原型5.jpg)

## 5、继承

### 5.1 原型链继承

将父构造函数创建的实例作为子构造函数的原型对象

```js
function Father() {
  this.colors = ["red", "blue", "green"];
}
function Son() { }
// 继承 SuperType
Son.prototype = new Father();
let instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors); // "red,blue,green,black"
let instance2 = new Son();
console.log(instance2.colors); // "red,blue,green,black"
```

**优点**：

1. 能继承父类的属性和方法，以及父类原型上的属性和方法

**缺点**：

1. 原型中包含的引用值会在所有实例中共享
2. 子类型在实例化时不能给父类型传参

### 5.2 盗用构造函数

```js
function Father() {
  this.colors = ["red", "blue", "green"];
}
function Son() {
  console.log(this); //this指向new出来的新对象，对象是Son的实例
  Father.call(this)  // 把属性挂到实例上
}

let instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors); // ["red,blue,green,black"]
let instance2 = new Son();
console.log(instance2.colors); // ["red,blue,green"]
```

**优点：**

1. 可以继承多个父类
2. 解决了原型链继承两个问题：
   1. 引用值在实例间共享的问题（通过call方法，每实例对象都有自己的属性）
   2. 不能传参的问题

**缺点：**

1. 方法都在构造函数中定义，无法复用
2. 不能访问父类原型上的属性和方法

### 5.3 组合继承

**基本思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。**

```js
function Father(name) {
  this.name = name;
  this.color = ["red", "blue", "green"];
}

Father.prototype.sayName = function () {
  console.log(this.name);
}

function Son(name, age) {
  Father.call(this, name)
  this.age = age
}

Son.prototype = new Father()
Son.prototype.sayAge = function () {
  console.log(this.age);
}
let instance1 = new Son('Nanyi', 29)
instance1.color.push('black')

console.log(instance1.color);
instance1.sayAge()
instance1.sayName()


let instance2 = new Son('Naner', 22)
console.log(instance2.color);
instance2.sayAge()
instance2.sayName()

console.log(instance1 instanceof Father);
```

**优点：**

既然是结合了原型链继承和盗用构造函数继承，那么两者的优点他都有

1. 能继承父类的属性和方法，以及父类原型上的属性和方法
2. 可传参
3. 函数可复用

**缺点：**

1. 父类被实例化了两次，所以有两份实例数据

### 5.4 寄生式继承

**寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种 方式增强对象，然后返回这个对象**

```js
function createAnother(original) {
  let clone = object(original)
  clone.sayHi = function () {
    console.log("Hi");
  }
  return clone;
}
```

### 5.5 寄生组合继承（完美继承）

组合继承的缺点，父类构造函数会被调用两次。继承原型时，那些实例属性和方法是冗余的。

```js
function Father(name) {
  this.name = name;
  this.color = ["red", "blue", "green"];
}

Father.prototype.sayName = function () {
  console.log(this.name);
}

function Son(name, age) {
  Father.call(this, name)
  this.age = age
}

// Son.prototype = new Father() //组合继承用的

/**
 * 把父类原型的副本当成子类原型,并把原型的constructor属性指回子类,因为重写原型
 * @param {*} Father 父类 
 * @param {*} Son 子类
 */
function inheritPrototype(Father, Son) {
  // 不能直接改变Father.prototype.constructor，这样就破环父类了，所以间接通过一个新类F完成原型链继承
  function F() { }
  F.prototype = Father.prototype;
  Son.prototype = new F();
  Son.prototype.constructor = Son;
}

inheritPrototype(Father, Son)

Son.prototype.sayAge = function () {
  console.log(this.age);
}

let instance1 = new Son('Nanyi', 29)
instance1.color.push('black')

console.log(instance1.color); //[ 'red', 'blue', 'green', 'black' ]
instance1.sayAge() // 29
instance1.sayName() //Nanyi


let instance2 = new Son('Naner', 22)
console.log(instance2.color); // [ 'red', 'blue', 'green' ]
instance2.sayAge() //22
instance2.sayName() //Naner

console.log(instance1 instanceof Father); //true
```

**优点：**

1. 能继承父类的属性和方法，以及父类原型上的属性和方法
2. 可传参
3. 函数可复用
4. 父类只实例化一次

## 6、作用域、作用域链、执行上下文

**作用域**定义了**变量**和**函数**的可见性和生命周期（可访问性），作用域链则决定了变量在嵌套函数中的查找顺序。

作用域分为**全局作⽤域**和**局部作用域**，局部作用域又分为**函数作⽤域**和**块级作⽤域**。

JavaScript 代码会经过编译再执行，编译形成两部分内容，执行上下文和可执行代码。

**执行上下文（Execution Context）：**

​		执行上下文包含了代码执行时需要用到的**this，变量环境，作用域链**。执行上下文分为：

1. 全局执行上下文：当JavaScript程序首次运行时创建，它会在浏览器中创建一个全局对象（window对象），使this指向这个全局对象。
2. 函数执行上下文：当函数被调用时创建，每次调用都会为该函数创建一个新的执行上下文。函数执行上下文会在调用栈中排队等待执行，当函数执行完后，其执行上下文从栈顶出栈，回到调用它的函数执行上下文中继续执行。
3. Eval函数执行上下文：指的是运行Eval函数中的代码时创建的执行上下文。这种类型较少使用，且不建议使用。

**变量环境（Variable Environment）：**

​		变量环境是JavaScript中用来存储变量的地方。它通常与执行上下文（Execution Context）相关联，每个执行上下文都有自己的变量环境。变量环境包括变量和函数声明，这些变量和函数声明在执行上下文被创建时由JavaScript引擎动态添加。当一个函数被调用时，该函数的作用域链（Scope Chain）将链接到该函数的变量环境，以便在执行期间查找变量和函数。

**作用域链（Scope Chain）：**

​		作用域链是执行上下文中的变量环境和其他执行上下文的变量环境的集合。执行上下文的变量环境中有一个特殊变量outer指针，指向外部的执行上下文。当代码中使用一个变量时，JS引擎会先在当前的执行上下文中查找该变量，如果没找到就会沿着outer指针，去上一级的执行上下文查找，直到找到该变量或到达作用域链的顶部。

**词法作用域（lexical scoping）：**

​		我理解也是一个概念，就是说JavaScript，在编译时就确定了作用域链，确定了变量的查找顺序。

**执行上下文栈（Execution Context Stack）：**

​		执行上下文栈是JavaScript引擎中用于管理执行上下文的一个数据结构。它是一个栈结构，遵循后进先出（LIFO）的原则。当一个函数被调用时，会创建一个新的执行上下文并推入执行上下文栈的顶部。这个执行上下文包括函数本身的代码块、变量环境、作用域链等信息。在函数执行过程中，如果遇到其他的函数调用，会再次创建一个新的执行上下文并推入栈中，形成嵌套的执行上下文。当函数执行完毕后，相应的执行上下文会从栈中弹出，回到调用它的函数执行上下文中继续执行。这个过程是自动进行的，开发者不需要手动管理。

> 作用域和执行上下文的理解：作用域我理解是一个概念，决定变量和函数的可见性；而执行上下文，是一个具体的内部实现，通过栈结构，使得JavaScript能够在动态的环境中正确地管理和查找变量。



























