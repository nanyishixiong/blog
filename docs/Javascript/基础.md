## 1、说说JavaScript中的数据类型？存储上的差别？

在 JavaScript 中，数据可以分成两种类型：

基本类型：Number，String，Boolean，Null，undefined，Symbol，BigInt

复杂类型：Object（包括Array，Function，Date等等）

两种类型的区别是：存储位置不同

+ 基本数据类型存储在栈中
+ 引⽤类型的对象存储于堆中

## 2、数据类型的判断

### 2.1 typeof 操作符

返回值是字符串：number，bigint，string，boolean，undefined，function，object，symbol

#### number

```js
//输出 number
console.log(typeof 1);
console.log(typeof NaN);  		 // 尽管他是Not-A-Number
console.log(typeof Number('1')); // Number 会尝试把参数解析成数值
console.log(typeof Infinity);	 // 无限大也是number
```

#### bigint

```js
console.log(typeof 42n);		 // 这个输出bigint
```

#### string

```js
//输出 string
console.log(typeof 'mc');
console.log(typeof '');
console.log(typeof `adadad`); // 模板字符串
console.log(typeof (typeof 1)); // typeof 操作符 返回字符串
console.log(typeof String(1)); // String 将任意值转换为字符串，比 toString 更安全
```

#### boolean

```js
//输出 boolean
console.log(typeof true);
console.log(typeof Boolean(1)); // Boolean(1)是true  Boolean(0)是false
console.log(typeof !!(1));// 两次调用 ! (逻辑非) 操作符相当于 Boolean() true
```

#### undefined

**声明但未初始化**和**未声明**  `typeof`输出都是"`undefined`"，但直接打印**未声明变量**是会报错的

```js
console.log(typeof undefined);          // undefined
console.log(typeof console.log());      // undefined
```

#### function

```js
console.log(typeof Symbol)              // function
console.log(typeof function () { });    // function
console.log(typeof new Function())      // function
```

#### object

```js
// object
console.log(typeof []);
console.log(typeof {});
console.log(typeof null);
console.log(typeof new Date()); // 除 Function 外的所有构造函数的类型都是 'object'
console.log(typeof /regex/);
```

#### symbol

```js
//symbol
console.log(typeof Symbol());
console.log(typeof Symbol('foo'));
console.log(typeof Symbol.iterator);
```

优点：能够快速区分基本数据类型
缺点：不能将Object、Array和Null区分，都返回object

**typeof 实现原理：**

js 在底层是怎么存储数据的类型信息呢？

其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息

+ 000：对象
+ 010：浮点数
+ 100：字符串
+ 110：布尔
+ 1：整数

但是，对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的。

`null`：所有机器码均为0

`undefined`：用 −2^30 整数来表示

所以，`typeof` 在判断 `null` 的时候就出现问题了，由于 `null` 的所有机器码均为0，因此直接被当做了对象来看待。

### 2.2 instanceof 运算符

`instanceof`运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。
`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```js
console.log(1 instanceof Number);                       // false
console.log(true instanceof Boolean);                   // false
console.log('str' instanceof String);                   // false
console.log([] instanceof Array);                       // true
console.log(function () { } instanceof Function);       // true
console.log({} instanceof Object);                      // true
```

优点：能够区分Array、Object、Function，适用于判断自定义的类实例对象
缺点：Nunber、boolean、String基本数据类型不能判断

#### instanceof 原理模拟实现

```js
function new_instance_of(leftVaule, rightVaule) {
    var rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;
        }
        if (leftVaule === rightProto) {
            return true;
        }
        leftVaule = leftVaule.__proto__
    }
}
```

其实 `instanceof` 主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

### 2.3 Object.prototype.toString.call()

```js
var toString = Object.prototype.toString;
console.log(toString.call(1));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('mc'));                   //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(function () { }));        //[object Function]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
console.log(toString.call(Symbol()));               //[object Symbol]
```

优点：精准判断数据类型
缺点：写法繁琐不容易记，推荐进行封装后使用

#### **简单封装**

```js
let typeUtil = {};
let types = ['String', 'Array', 'Number', 'Object', 'Undefined', 'Null', 'Boolean', 'Function', 'Symbol'];
types.forEach(type => {
  typeUtil['is' + type] = function (obj) {
    return Object.prototype.toString.call(obj) === `[object ${type}]`;
  }
})
console.log(typeUtil);
//{
//  isString: [Function (anonymous)],
//  isArray: [Function (anonymous)],
//  isNumber: [Function (anonymous)],
//  isObject: [Function (anonymous)],
//  isUndefined: [Function (anonymous)],
//  isNull: [Function (anonymous)],
//  isBoolean: [Function (anonymous)],
//  isFunction: [Function (anonymous)],
//  isSymbol: [Function (anonymous)]
//}
```

由于`String`基本包装类型的存在，在必要的时候`JS`引擎会把字符串字面量转换成一个`String`对象，从而可以执行访问属性和方法的操作

**Object**类型的每个实例都有`toString`方法，返回值为对象的字符串表示，所以每个实例化的对象都可以调用`toString`方法。

## 3、== 与 === 有什么区别（隐式转换）

== ：操作符两端类型不同会进行隐式转换再做比较，相等返回true，否则返回false

=== ：操作符两端操作数要完全相同，包括类型，才返回true，否则返回false

隐式转换规则

- 如果任一操作数是布尔值，则将其转换成数值再比较是否相等，flase转换为0，true转换为1
- 如果一个操作数是字符串，另一个操作数是数值，则调用 Number 方法将字符串转换为数值再进行比较是否相等
- 如果一个操作数是对象，另一个不是，则调用 valueof() 方法取得对象的原始值，再按前面的规则进行比较；如果没有 valueOf()操作符，则调用 toString()方法，再按前面的规则进行比较
- null 和 undefined 相等
- null 和 undefined 不能转换成其他类型的值再进行比较
- 如果有任一操作数为 NaN 则相等操作符返回false，不相等操作符返回true，NaN不等于NaN
- 如果两个操作数是对象，则比较是不是同一个对象，是返回true，不是返回false

```js
// 2个字符串比较，对操作数调用 charCodeAt
'' == '0' // false 
// ''.charCodeAt(0) -> NaN  '0'.charCodeAt(0) -> 48

// 数字与字符串比较，对字符串调用Number方法
0 == '' // true
0 == '0' // true
' \t\r\n' == 0 // true
// Number('') -> 0 Number('0') -> 0 Number(' \t\r\n') -> 0 Number(空串)都是0

// 布尔值与字符串比较，将布尔值转成数字，再将字符串转为数字
false == 'false' // false
false == '0' // true
// Number(false) -> 0 Number('false') -> NaN Number('0') -> 0

// null 和 undefined 与任何其他值比较都为false
false == undefined // false
false == null // false
undefined == undefined // true
null == null // true
null == undefined // true
```

## 4、JavaScript 的原型和原型链

JavaScript 常被描述为⼀种基于原型的语⾔——JavaScript 中的对象有一个私有属性`__proto__`，指向一个对象名曰**原型**(prototype)

当试图访问⼀个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到⼀个名字匹配的属性或到达原型链的末尾。

只要是对象，就会有`__proto__`属性指向它的原型，原型也是一个对象，也会有自己的原型。这种类似链表结构的关系就被称为**原型链**

![原型5](./image/原型5.png)

## 5、继承

### 5.1 原型链继承

将父构造函数创建的实例作为子构造函数的原型对象

```js
function Father() {
  this.colors = ["red", "blue", "green"];
}
function Son() { }
// 继承 SuperType
Son.prototype = new Father();
let instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors); // "red,blue,green,black"
let instance2 = new Son();
console.log(instance2.colors); // "red,blue,green,black"
```

**优点**：

1. 能继承父类的属性和方法，以及父类原型上的属性和方法

**缺点**：

1. 原型中包含的引用值会在所有实例中共享
2. 子类型在实例化时不能给父类型传参

### 5.2 盗用构造函数

```js
function Father() {
  this.colors = ["red", "blue", "green"];
}
function Son() {
  console.log(this); //this指向new出来的新对象，对象是Son的实例
  Father.call(this)  // 把属性挂到实例上
}

let instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors); // ["red,blue,green,black"]
let instance2 = new Son();
console.log(instance2.colors); // ["red,blue,green"]
```

**优点：**

1. 可以继承多个父类
2. 解决了原型链继承两个问题：
   1. 引用值在实例间共享的问题（通过call方法，每实例对象都有自己的属性）
   2. 不能传参的问题

**缺点：**

1. 方法都在构造函数中定义，无法复用
2. 不能访问父类原型上的属性和方法

### 5.3 组合继承

**基本思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。**

```js
function Father(name) {
  this.name = name;
  this.color = ["red", "blue", "green"];
}

Father.prototype.sayName = function () {
  console.log(this.name);
}

function Son(name, age) {
  Father.call(this, name)
  this.age = age
}

Son.prototype = new Father()
Son.prototype.sayAge = function () {
  console.log(this.age);
}
let instance1 = new Son('Nanyi', 29)
instance1.color.push('black')

console.log(instance1.color);
instance1.sayAge()
instance1.sayName()


let instance2 = new Son('Naner', 22)
console.log(instance2.color);
instance2.sayAge()
instance2.sayName()

console.log(instance1 instanceof Father);
```

**优点：**

既然是结合了原型链继承和盗用构造函数继承，那么两者的优点他都有

1. 能继承父类的属性和方法，以及父类原型上的属性和方法
2. 可传参
3. 函数可复用

**缺点：**

1. 父类被实例化了两次，所以有两份实例数据

### 5.4 寄生式继承

**寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种 方式增强对象，然后返回这个对象**

```js
function createAnother(original) {
  let clone = object(original)
  clone.sayHi = function () {
    console.log("Hi");
  }
  return clone;
}
```

### 5.5 寄生组合继承（完美继承）

组合继承的缺点，父类构造函数会被调用两次。继承原型时，那些实例属性和方法是冗余的。

```js
function Father(name) {
  this.name = name;
  this.color = ["red", "blue", "green"];
}

Father.prototype.sayName = function () {
  console.log(this.name);
}

function Son(name, age) {
  Father.call(this, name)
  this.age = age
}

// Son.prototype = new Father() //组合继承用的

/**
 * 把父类原型的副本当成子类原型,并把原型的constructor属性指回子类,因为重写原型
 * @param {*} Father 父类 
 * @param {*} Son 子类
 */
function inheritPrototype(Father, Son) {
  // 不能直接改变Father.prototype.constructor，这样就破环父类了，所以间接通过一个新类F完成原型链继承
  function F() { }
  F.prototype = Father.prototype;
  Son.prototype = new F();
  Son.prototype.constructor = Son;
}

inheritPrototype(Father, Son)

Son.prototype.sayAge = function () {
  console.log(this.age);
}

let instance1 = new Son('Nanyi', 29)
instance1.color.push('black')

console.log(instance1.color); //[ 'red', 'blue', 'green', 'black' ]
instance1.sayAge() // 29
instance1.sayName() //Nanyi


let instance2 = new Son('Naner', 22)
console.log(instance2.color); // [ 'red', 'blue', 'green' ]
instance2.sayAge() //22
instance2.sayName() //Naner

console.log(instance1 instanceof Father); //true
```

**优点：**

1. 能继承父类的属性和方法，以及父类原型上的属性和方法
2. 可传参
3. 函数可复用
4. 父类只实例化一次

## 6、作用域和作用域链

**作用域**是指**变量**和**函数**在其中**可见**或**可被访问**的区域，也叫执行上下文。有三种作用域：

+ 全局作⽤域
+ 函数作⽤域
+ 块级作⽤域









